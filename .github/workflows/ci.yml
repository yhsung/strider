name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  # Test on Linux with GCC and Clang
  test-linux:
    name: Linux (${{ matrix.compiler }}, ${{ matrix.build_type }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        compiler: [gcc, clang]
        build_type: [Debug, Release]
        include:
          - compiler: gcc
            cc: gcc
            cxx: g++
          - compiler: clang
            cc: clang
            cxx: clang++

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ccache valgrind

    - name: Cache ccache
      uses: actions/cache@v4
      with:
        path: ~/.ccache
        key: ccache-${{ runner.os }}-${{ matrix.compiler }}-${{ matrix.build_type }}-${{ github.sha }}
        restore-keys: |
          ccache-${{ runner.os }}-${{ matrix.compiler }}-${{ matrix.build_type }}-

    - name: Configure CMake
      env:
        CC: ${{ matrix.cc }}
        CXX: ${{ matrix.cxx }}
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
          -DCMAKE_C_COMPILER_LAUNCHER=ccache \
          -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
          -DSTRIDER_BUILD_TESTS=ON \
          -DSTRIDER_BUILD_EXAMPLES=ON

    - name: Build
      run: cmake --build build --config ${{ matrix.build_type }} -j $(nproc)

    - name: Run tests
      id: test_results
      working-directory: build
      run: |
        # Run tests and generate JUnit XML for parsing
        ctest --output-on-failure --build-config ${{ matrix.build_type }} --output-junit test_results.xml

        # Extract test counts for accumulation
        TOTAL=$(sed -n 's/.*tests="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        FAILURES=$(sed -n 's/.*failures="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        PASSED=$((TOTAL - FAILURES))
        
        # Save to file
        echo "passed=$PASSED" > test_counts.txt
        echo "total=$TOTAL" >> test_counts.txt
        
        echo "Test Results: $PASSED/$TOTAL tests passed"

    - name: Upload test counts
      uses: actions/upload-artifact@v4
      with:
        name: test-counts-linux-${{ matrix.compiler }}-${{ matrix.build_type }}
        path: build/test_counts.txt

    - name: Run example
      working-directory: build
      run: ./examples/cpu_info

  # Test on Linux with sanitizers (GCC only for now)
  test-sanitizers:
    name: Linux (Sanitizers)
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Configure with AddressSanitizer
      env:
        CC: gcc
        CXX: g++
      run: |
        cmake -B build-asan \
          -DCMAKE_BUILD_TYPE=Debug \
          -DSTRIDER_BUILD_TESTS=ON \
          -DSTRIDER_ENABLE_ASAN=ON

    - name: Build with ASan
      run: cmake --build build-asan -j $(nproc)

    - name: Run tests with ASan
      working-directory: build-asan
      run: |
        ctest --output-on-failure --output-junit test_results.xml
        
        TOTAL=$(sed -n 's/.*tests="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        FAILURES=$(sed -n 's/.*failures="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        PASSED=$((TOTAL - FAILURES))
        
        echo "passed=$PASSED" > ../test_counts_asan.txt
        echo "total=$TOTAL" >> ../test_counts_asan.txt

    - name: Configure with UndefinedBehaviorSanitizer
      env:
        CC: gcc
        CXX: g++
      run: |
        cmake -B build-ubsan \
          -DCMAKE_BUILD_TYPE=Debug \
          -DSTRIDER_BUILD_TESTS=ON \
          -DSTRIDER_ENABLE_UBSAN=ON

    - name: Build with UBSan
      run: cmake --build build-ubsan -j $(nproc)

    - name: Run tests with UBSan
      working-directory: build-ubsan
      run: |
        ctest --output-on-failure --output-junit test_results.xml
        
        TOTAL=$(sed -n 's/.*tests="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        FAILURES=$(sed -n 's/.*failures="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        PASSED=$((TOTAL - FAILURES))
        
        echo "passed=$PASSED" > ../test_counts_ubsan.txt
        echo "total=$TOTAL" >> ../test_counts_ubsan.txt

    - name: Combine sanitizer counts
      run: |
        # Sum up counts from both runs
        source test_counts_asan.txt
        ASAN_PASSED=$passed
        ASAN_TOTAL=$total
        
        source test_counts_ubsan.txt
        UBSAN_PASSED=$passed
        UBSAN_TOTAL=$total
        
        TOTAL=$((ASAN_TOTAL + UBSAN_TOTAL))
        PASSED=$((ASAN_PASSED + UBSAN_PASSED))
        
        echo "passed=$PASSED" > test_counts.txt
        echo "total=$TOTAL" >> test_counts.txt

    - name: Upload test counts
      uses: actions/upload-artifact@v4
      with:
        name: test-counts-linux-sanitizers
        path: test_counts.txt

  # Test on macOS (ARM64 Apple Silicon only)
  test-macos:
    name: macOS (ARM64, Release)
    runs-on: macos-14

    steps:
    - uses: actions/checkout@v4

    - name: Configure CMake
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Release \
          -DSTRIDER_BUILD_TESTS=ON \
          -DSTRIDER_BUILD_EXAMPLES=ON

    - name: Build
      run: cmake --build build --config Release -j $(sysctl -n hw.ncpu)

    - name: Run tests
      working-directory: build
      run: |
        ctest --output-on-failure --build-config Release --output-junit test_results.xml
        
        TOTAL=$(sed -n 's/.*tests="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        FAILURES=$(sed -n 's/.*failures="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        PASSED=$((TOTAL - FAILURES))
        
        echo "passed=$PASSED" > test_counts.txt
        echo "total=$TOTAL" >> test_counts.txt

    - name: Upload test counts
      uses: actions/upload-artifact@v4
      with:
        name: test-counts-macos
        path: build/test_counts.txt

    - name: Run example
      working-directory: build
      run: ./examples/cpu_info

  # Test coverage report (Linux GCC Debug only)
  test-coverage:
    name: Coverage Report
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y lcov

    - name: Configure with coverage
      env:
        CC: gcc
        CXX: g++
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DSTRIDER_BUILD_TESTS=ON \
          -DCMAKE_C_FLAGS="--coverage -fprofile-arcs -ftest-coverage"

    - name: Build
      run: cmake --build build -j $(nproc)

    - name: Run tests
      working-directory: build
      run: ctest --output-on-failure

    - name: Generate coverage report
      run: |
        lcov --capture --directory build --output-file coverage.info
        lcov --remove coverage.info '/usr/*' '*/tests/*' --output-file coverage.info --ignore-errors unused
        lcov --list coverage.info

    - name: Extract coverage percentage
      id: coverage
      run: |
        COVERAGE=$(lcov --summary coverage.info 2>&1 | grep "lines" | awk '{print $2}' | sed 's/%//')
        echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "### Coverage Report" >> $GITHUB_STEP_SUMMARY
        echo "**Line Coverage: $COVERAGE%**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        lcov --list coverage.info >> $GITHUB_STEP_SUMMARY

    - name: Create coverage badge JSON
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        COVERAGE="${{ steps.coverage.outputs.percentage }}"
        # Determine badge color based on coverage
        if (( $(echo "$COVERAGE >= 90" | bc -l) )); then
          COLOR="brightgreen"
        elif (( $(echo "$COVERAGE >= 75" | bc -l) )); then
          COLOR="green"
        elif (( $(echo "$COVERAGE >= 60" | bc -l) )); then
          COLOR="yellow"
        else
          COLOR="red"
        fi

        # Create badge JSON
        cat > coverage-badge.json <<EOF
        {
          "schemaVersion": 1,
          "label": "coverage",
          "message": "${COVERAGE}%",
          "color": "${COLOR}"
        }
        EOF

        cat coverage-badge.json

    - name: Update coverage badge gist
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: exuanbo/actions-deploy-gist@v1
      with:
        token: ${{ secrets.GIST_TOKEN }}
        gist_id: ${{ secrets.GIST_ID }}
        file_path: coverage-badge.json
        file_type: text
      continue-on-error: true

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        files: ./coverage.info
        fail_ci_if_error: false
        verbose: true
      continue-on-error: true

  # Check code formatting and style
  check-format:
    name: Code Format Check
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Install clang-format
      run: sudo apt-get update && sudo apt-get install -y clang-format

    - name: Check code formatting with clang-format
      run: |
        # Find all C/H files excluding Unity framework
        FILES=$(find . \
          -path "./build" -prune -o \
          -path "./tests/unity" -prune -o \
          -type f \( -name "*.c" -o -name "*.h" \) -print)

        FAILED=0
        for file in $FILES; do
          if ! clang-format --dry-run --Werror "$file" 2>/dev/null; then
            echo "âŒ $file needs formatting"
            FAILED=1
          fi
        done

        if [ $FAILED -eq 1 ]; then
          echo ""
          echo "Format check failed!"
          echo "Run './scripts/format-code.sh' locally to fix formatting."
          exit 1
        fi

    - name: Check for trailing whitespace
      run: |
        if grep -r --include="*.c" --include="*.h" '[[:space:]]$' .;
        then
          echo "Found trailing whitespace"
          exit 1
        fi

  # Build and test on Windows with MSVC
  test-windows:
    name: Windows (MSVC, ${{ matrix.build_type }})
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        build_type: [Debug, Release]

    steps:
    - uses: actions/checkout@v4

    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Configure CMake
      run: |
        cmake -B build `
          -G "Visual Studio 17 2022" `
          -A x64 `
          -DSTRIDER_BUILD_TESTS=ON `
          -DSTRIDER_BUILD_EXAMPLES=ON

    - name: Build
      run: cmake --build build --config ${{ matrix.build_type }}

    - name: Run tests
      working-directory: build
      shell: bash
      run: |
        ctest -C ${{ matrix.build_type }} --output-on-failure --output-junit test_results.xml
        
        TOTAL=$(sed -n 's/.*tests="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        FAILURES=$(sed -n 's/.*failures="\([0-9]*\)".*/\1/p' test_results.xml | head -n 1)
        PASSED=$((TOTAL - FAILURES))
        
        echo "passed=$PASSED" > test_counts.txt
        echo "total=$TOTAL" >> test_counts.txt

    - name: Upload test counts
      uses: actions/upload-artifact@v4
      with:
        name: test-counts-windows-${{ matrix.build_type }}
        path: build/test_counts.txt

    - name: Run example
      working-directory: build/examples/${{ matrix.build_type }}
      run: ./cpu_info.exe

  # Finalize: Aggregate test results and check status
  ci-finalize:
    name: CI Finalize & Badge
    needs: [test-linux, test-sanitizers, test-macos, test-windows, test-coverage, check-format]
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Check workflow status
      run: |
        if [[ "${{ needs.test-linux.result }}" != "success" ]] || \
           [[ "${{ needs.test-sanitizers.result }}" != "success" ]] || \
           [[ "${{ needs.test-macos.result }}" != "success" ]] || \
           [[ "${{ needs.test-windows.result }}" != "success" ]]; then
          echo "One or more required jobs failed"
          exit 1
        fi
        echo "All required CI jobs passed!"

    - name: Download all test counts
      uses: actions/download-artifact@v4
      with:
        pattern: test-counts-*
        path: test_counts
        merge-multiple: true

    - name: Aggregate Test Counts
      id: aggregate
      run: |
        TOTAL_SUM=0
        PASSED_SUM=0
        
        # Iterate over all downloaded count files
        for file in test_counts/test_counts*.txt; do
          if [ -f "$file" ]; then
             # Sourcing vars (safe here as we control content)
             source "$file"
             TOTAL_SUM=$((TOTAL_SUM + total))
             PASSED_SUM=$((PASSED_SUM + passed))
          elif [ -f "test_counts/$file" ]; then
             source "test_counts/$file"
             TOTAL_SUM=$((TOTAL_SUM + total))
             PASSED_SUM=$((PASSED_SUM + passed))
          fi
        done
        
        # Handle case where download-artifact structure differs (it might put files in subdirs or flat)
        # Using find to be safe
        FILES=$(find test_counts -name "*.txt")
        TOTAL_SUM=0
        PASSED_SUM=0
        
        for file in $FILES; do
          # Read file content
          source "$file"
          echo "Processing $file: passed=$passed, total=$total"
          TOTAL_SUM=$((TOTAL_SUM + total))
          PASSED_SUM=$((PASSED_SUM + passed))
        done
        
        echo "total=$TOTAL_SUM" >> $GITHUB_OUTPUT
        echo "passed=$PASSED_SUM" >> $GITHUB_OUTPUT
        echo "### Test Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Total Tests Executed:** $TOTAL_SUM" >> $GITHUB_STEP_SUMMARY
        echo "**Total Passed:** $PASSED_SUM" >> $GITHUB_STEP_SUMMARY

    - name: Create test badge JSON
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        TOTAL="${{ steps.aggregate.outputs.total }}"
        PASSED="${{ steps.aggregate.outputs.passed }}"

        # Determine badge color
        if [ "$PASSED" = "$TOTAL" ] && [ "$TOTAL" -gt 0 ]; then
          COLOR="brightgreen"
        else
          COLOR="red"
        fi

        # Create badge JSON
        cat > test-badge.json <<EOF
        {
          "schemaVersion": 1,
          "label": "tests",
          "message": "${PASSED}/${TOTAL} passing",
          "color": "${COLOR}"
        }
        EOF
        
        echo "Generated Badge JSON:"
        cat test-badge.json

    - name: Update test badge gist
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: exuanbo/actions-deploy-gist@v1
      with:
        token: ${{ secrets.GIST_TOKEN }}
        gist_id: ${{ secrets.GIST_ID }}
        file_path: test-badge.json
        file_type: text
      continue-on-error: true